
<p><big><b>5. Compiling the software and uploading it into the synthesized system using Serial Loader</b></big></p>

<p><big><b>5.1. Files in the first lab directory</b></big></p>

<p><table border=1 cellpadding=10 cellspacing=0 rules=all>
<col width=250>
<col width=450>
<tr>
<th>File</th>
<th>Description</th>
</tr><tr><td>

<i>00_clean_all.bat<br>
01_compile_c_to_assembly.bat<br>
02_compile_and_link.bat<br>
03_check_program_size.bat<br>
04_disassemble.bat<br>
05_generate_verilog_readmemh_file.bat<br>
06_simulate_with_modelsim.bat<br>
07_simulate_with_icarus.bat<br>
08_generate_motorola_s_record_file.bat<br>
09_upload_to_xilinx_board_using_bus_blaster.bat<br>
10_upload_to_altera_board_using_bus_blaster.bat<br>
11_check_which_com_port_is_used.bat<br>
12_upload_to_the_board_using_uart.bat<br></i>

</td><td>

A set of Windows batch files with self-descriptive names to guide a user through the lab step-by-step.
Some of these steps duplicate actions in the <i>makefile</i>. We found using these batch files
during the first experience with MIPSfpga makes lab more digestible and less confusing
for a number of people since they can just click on batch files in Windows explorer
or other file manager instead of typing "make action" to go through the steps.
These files are discussed in more details in subsequent subchapters.

</td></tr><tr><td>

<i>00_clean_all.sh<br>
01_compile_c_to_assembly.sh<br>
02_compile_and_link.sh<br>
03_check_program_size.sh<br>
04_disassemble.sh<br>
05_generate_verilog_readmemh_file.sh<br>
06_simulate_with_modelsim.sh<br>
07_simulate_with_icarus.sh<br>
08_generate_motorola_s_record_file.sh<br>
09_upload_to_xilinx_board_using_bus_blaster.sh<br>
10_upload_to_altera_board_using_bus_blaster.sh<br>
11_check_which_com_port_is_used.sh<br>
12_upload_to_the_board_using_uart.sh<br></i>

</td><td>

A set of Linux Bourne shell scripts with self-descriptive names to guide a user through the lab step-by-step.
See the description of Windows batch files above. Linux shell scripts and Windows batch files
generally match each other except for <i>12_upload_to_the_board_using_uart.sh</i> that uses different
Linux-specific commands comparing to Windows-specific <i>12_upload_to_the_board_using_uart.bat</i>.

</td></tr><tr><td>
<i>boot.S</i>
</td><td>

Boot sequence, a program in assemply that starts after the processor reset,
initializes system coprocessor registers, caches and TLB MMU, then jumps into the user's program.

</td></tr><tr><td>
<i>main.c</i>
</td><td>

User's program written in C.

</td></tr><tr><td>
<i>makefile</i>
</td><td>

Makefile that contans basic tasks for compiling and linking the program.
Can be used instead of supplied Windows batch files and Linux scripts.

</td></tr><tr><td>
<i>mfp_memory_mapped_registers.h</i>
</td><td>

Header file that contains definitions for the memory-mapped I/O registers
used to communicate the software with I/O devices on the board - buttons, LEDs,
as well as external devices connected through general-purpose I/O ports. 

</td></tr><tr><td>
<i>modelsim_script.tcl</i>
</td><td>

A script in Tcl language used by Mentor ModelSim RTL simulator
to automate Verilog compilation, running the simulation and controlling displaying waveforms.

</td></tr><tr><td>
<i>program.ld</i>
</td><td>

A linker script used by GCC toolchain.
Defines virtual memory locations for boot sequence, user program and data.

</td></tr>
</table></p>

<p><big><b>5.2. The first lab program</b></big></p>

#include "mfp_memory_mapped_registers.h"

int main ()
{
    long long int n = 0;

    for (;;)
    {
        /*
        MFP_RED_LEDS      = n;
        MFP_GREEN_LEDS    = n;
        MFP_7_SEGMENT_HEX = n;
        */

        MFP_RED_LEDS   = n >> 16;
        MFP_GREEN_LEDS = n >> 16;
        MFP_7_SEGMENT_HEX = ((n >> 8) & 0xffffff00) | (n & 0xff);

        n ++;

        // asm ("mfc0 $8, $15, 0");
        // MFP_7_SEGMENT_HEX = 1;
    }

    return 0;
}


<p><big><b>5.3. The steps overview</b></big></p>

<p><big><b>5.3.1. Batch files and Bourne Shell scripts for going through the steps</b></big></p>

<ul>
<li><i>01_compile_c_to_assembly.bat</i></li>
<li><i>02_compile_and_link.bat</i></li>
<li><i>03_check_program_size.bat</i></li>
<li><i>04_disassemble.bat</i></li>
<li><i>05_generate_verilog_readmemh_file.bat</i></li>
<li><i>06_simulate_with_modelsim.bat</i></li>
<li><i>07_simulate_with_icarus.bat</i></li>
<li><i>08_generate_motorola_s_record_file.bat</i></li>
<li><i>09_upload_to_xilinx_board_using_bus_blaster.bat</i></li>
<li><i>10_upload_to_altera_board_using_bus_blaster.bat</i></li>
<li><i>11_check_which_com_port_is_used.bat</i></li>
<li><i>12_upload_to_the_board_using_uart.bat</i></li>
</ul>

<p><big><b>5.3.2. The essential and optional steps</b></big></p>

<p><big><b>5.3.3. Cleaning all</b></big></p>

<p>This step is optional.</p>

<blockquote><p>File <i>00_clean_all.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>                                  
rd /s /q sim

del *.o
del main.s
del program.elf
del program.map
del program.dis
del program*.hex
del program.rec
del FPGA_Ram.elf

</pre></font></blockquote>

<p><big><b>5.4. Compiling the software</b></big></p>

<p><big><b>5.4.1. Compiling C program into assembly to examine the generated code</b></big></p>

<p>This step is optional.</p>

<blockquote><p>File <i>01_compile_c_to_assembly.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>                      
rem -EL           - Little-endian
rem -march=m14kc  - MIPSfpga = MIPS microAptiv UP based on MIPS M14Kc
rem -msoft-float  - should not use floating-point processor instructions
rem -O2           - optimization level
rem -S            - compile to assembly

mips-mti-elf-gcc -EL -march=m14kc -msoft-float -O2 -S main.c

</pre></font></blockquote>

<p><big><b>5.4.2. Compiling C and assembly programs and linking them into ELF file</b></big></p>

<p>This step is required.</p>

<blockquote><p>File <i>02_compile_and_link.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>                           
rem -EL             - Little-endian
rem -march=m14kc    - MIPSfpga = MIPS microAptiv UP based on MIPS M14Kc
rem -msoft-float    - should not use floating-point processor instructions
rem -o program.elf  - output file name
rem -O2             - optimization level
rem -T, -Wl         - linked options

mips-mti-elf-gcc -EL -march=m14kc -msoft-float -O2
    -Wl,-Map=program.map -T program.ld
    -Wl,--defsym,__flash_start=0xbfc00000
    -Wl,--defsym,__flash_app_start=0x80000000
    -Wl,--defsym,__app_start=0x80000000
    -Wl,--defsym,__stack=0x80040000
    -Wl,--defsym,__memory_size=0x1f800
    -Wl,-e,0xbfc00000
    boot.S main.c -o program.elf

</pre></font></blockquote>

<p><big><b>5.4.3. Checking program size</b></big></p>

<p>This step is optional.</p>

<blockquote><p>File <i>03_check_program_size.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>                         
mips-mti-elf-size program.elf

</pre></font></blockquote>

<p><big><b>5.4.4. Using disassembly program</b></big></p>

<p>This step is optional.</p>

<blockquote><p>File <i>04_disassemble.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>                                
mips-mti-elf-objdump -D program.elf &gt; program.dis

</pre></font></blockquote>

<p><big><b>5.5. Using Verilog simulation to model and debug both hardware and software </b></big></p>

<p>This step is optional.</p>

<p><big><b>5.5.1. Preparing Verilog $readmemh file with memory image for the software</b></big></p>

<p>This step is optional.</p>

<blockquote><p>File <i>05_generate_verilog_readmemh_file.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>             
mips-mti-elf-objcopy program.elf -O verilog program.hex
..\utilities\ad_hoc_program_hex_splitter

</pre></font></blockquote>

<p><big><b>5.5.2. Simulating the system using Mentor Graphics ModelSim</b></big></p>

<p>This step is optional.</p>

<blockquote><p>File <i>06_simulate_with_modelsim.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>                     
rd /s /q sim
md sim
cd sim

copy ..\*.hex .

vsim -do ../modelsim_script.tcl

</pre></font></blockquote>

<p><big><b>5.5.3. Simulating the system using Icarus Verilog</b></big></p>

<p>This step is optional.</p>

<blockquote><p>File <i>07_simulate_with_icarus.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>                       
rd /s /q sim
md sim
cd sim

copy ..\*.hex .

\iverilog\bin\iverilog -D SIMULATION -g2005
    -I ../../..
    -I ../../../../../MIPSfpga/rtl_up
    ../../../../../MIPSfpga/rtl_up/mvp*.v
    ../../../../../MIPSfpga/rtl_up/RAM*.v
    ../../../../../MIPSfpga/rtl_up/*xilinx.v
    ../../../../../MIPSfpga/rtl_up/m14k*.v
    ../../../*.v

\iverilog\bin\vvp a.out &gt; a.lst
\iverilog\gtkwave\bin\gtkwave.exe dump.vcd

</pre></font></blockquote>

<p><big><b>5.6. Uploading software program to the board</b></big></p>

<p><big><b>5.6.1. Generating the file in Motorola S-Record format</b></big></p>

<blockquote><p>File <i>08_generate_motorola_s_record_file.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>            
mips-mti-elf-objcopy program.elf -O srec program.rec

</pre></font></blockquote>

<p><big><b>5.6.2. Uploading ELF file into Xilinx FPGA board using Bus Blaster and OpenOCD software</b></big></p>

<p>This step is optional.</p>

<blockquote><p>File <i>09_upload_to_xilinx_board_using_bus_blaster.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>   
copy program.elf FPGA_Ram.elf
rem Yes, it is working with DE2_115 script
cd C:\MIPSfpga\Codescape\ExamplePrograms\Scripts\DE2_115
loadMIPSfpga.bat C:\github\mipsfpga-plus\programs\00_counter
cd C:\github\mipsfpga-plus\programs\00_counter
del FPGA_Ram.elf

</pre></font></blockquote>

<p><big><b>5.6.3. Uploading ELF file into Altera FPGA boards using Bus Blaster and OpenOCD software</b></big></p>

<p>This step is optional.</p>

<blockquote><p>File <i>10_upload_to_altera_board_using_bus_blaster.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>   
copy program.elf FPGA_Ram.elf
cd C:\MIPSfpga\Codescape\ExamplePrograms\Scripts\DE2_115
loadMIPSfpga.bat C:\github\mipsfpga-plus\programs\00_counter
cd C:\github\mipsfpga-plus\programs\00_counter
del FPGA_Ram.elf

</pre></font></blockquote>

<p><big><b>5.6.4. Checking which virtual COM port is used by USB-to-UART connector</b></big></p>

<p>This step is required.</p>

<blockquote><p>File <i>11_check_which_com_port_is_used.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>               
mode com0
mode com1
mode com2
mode com3
mode com4
mode com5
mode com6
mode com7
mode com8
mode com9
pause
mode com10
mode com11
. . . . . . . . .

</pre></font></blockquote>

<p><big><b>5.6.5. Checking which virtual COM port is used by USB-to-UART connector</b></big></p>

<p>This step is required.</p>

<blockquote><p>File <i>12_upload_to_the_board_using_uart.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>             
set a=16
set a=39
mode com%a% baud=115200 parity=n data=8 stop=1 to=off xon=off odsr=off octs=off dtr=off rts=off idsr=off
type program.rec &gt;\\.\COM%a%



</pre></font></blockquote>

stty -F /dev/ttyUSB0 raw speed 115200 -crtscts cs8 -parenb -cstopb
cat program.rec > /dev/ttyUSB0
