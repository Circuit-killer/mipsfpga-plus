
<p><big><b>5. Compiling the software and uploading it into the synthesized system using Serial Loader</b></big></p>

<p><big><b>5.1. Files in the first lab directory</b></big></p>

<p><table border=1 cellpadding=10 cellspacing=0 rules=all>
<col width=250>
<col width=450>
<tr>
<th>File</th>
<th>Description</th>
</tr><tr><td>

<i>00_clean_all.bat<br>
01_compile_c_to_assembly.bat<br>
02_compile_and_link.bat<br>
03_check_program_size.bat<br>
04_disassemble.bat<br>
05_generate_verilog_readmemh_file.bat<br>
06_simulate_with_modelsim.bat<br>
07_simulate_with_icarus.bat<br>
08_generate_motorola_s_record_file.bat<br>
09_upload_to_xilinx_board_using_bus_blaster.bat<br>
10_upload_to_altera_board_using_bus_blaster.bat<br>
11_check_which_com_port_is_used.bat<br>
12_upload_to_the_board_using_uart.bat<br></i>

</td><td>

<p>A set of Windows batch files with self-descriptive names to guide a user through the lab step-by-step.
Some of these steps duplicate actions in the <i>makefile</i>. We found using these batch files
during the first experience with MIPSfpga makes lab more digestible and less confusing
for a number of people since they can just click on batch files in Windows explorer
or other file manager instead of typing "make action" to go through the steps.
These files are discussed in more details in subsequent subchapters.</p>

<p>Only <i>02_compile_and_link.bat</i>, <i>08_generate_motorola_s_record_file.bat</i>
and <i>12_upload_to_the_board_using_uart.bat</i> are required for running the lab;
running the rest of batch files is optional.</p>

</td></tr><tr><td>

<i>00_clean_all.sh<br>
01_compile_c_to_assembly.sh<br>
02_compile_and_link.sh<br>
03_check_program_size.sh<br>
04_disassemble.sh<br>
05_generate_verilog_readmemh_file.sh<br>
06_simulate_with_modelsim.sh<br>
07_simulate_with_icarus.sh<br>
08_generate_motorola_s_record_file.sh<br>
09_upload_to_xilinx_board_using_bus_blaster.sh<br>
10_upload_to_altera_board_using_bus_blaster.sh<br>
11_check_which_com_port_is_used.sh<br>
12_upload_to_the_board_using_uart.sh<br></i>

</td><td>

<p>A set of Linux Bourne shell scripts with self-descriptive names to guide a user through the lab step-by-step.
See the description of Windows batch files above. Linux shell scripts and Windows batch files
generally match each other except for <i>12_upload_to_the_board_using_uart.sh</i> that uses different
Linux-specific commands comparing to Windows-specific <i>12_upload_to_the_board_using_uart.bat</i>.</p>

<p>Only <i>02_compile_and_link.sh</i>, <i>08_generate_motorola_s_record_file.sh</i>
and <i>12_upload_to_the_board_using_uart.sh</i> are required for running the lab;
running the rest of batch files is optional.</p>

</td></tr><tr><td>
<i>boot.S</i>
</td><td>

Boot sequence, a program in assemply that starts after the processor reset,
initializes system coprocessor registers, caches and TLB MMU, then jumps into the user's program.

</td></tr><tr><td>
<i>main.c</i>
</td><td>

User's program written in C.

</td></tr><tr><td>
<i>makefile</i>
</td><td>

Makefile that contans basic tasks for compiling and linking the program.
Can be used instead of supplied Windows batch files and Linux scripts.

</td></tr><tr><td>
<i>mfp_memory_mapped_registers.h</i>
</td><td>

Header file that contains definitions for the memory-mapped I/O registers
used to communicate the software with I/O devices on the board - buttons, LEDs,
as well as external devices connected through general-purpose I/O ports. 

</td></tr><tr><td>
<i>modelsim_script.tcl</i>
</td><td>

A script in Tcl language used by Mentor ModelSim RTL simulator
to automate Verilog compilation, running the simulation and controlling displaying waveforms.

</td></tr><tr><td>
<i>program.ld</i>
</td><td>

A linker script used by GCC toolchain.
Defines virtual memory locations for boot sequence, user program and data.

</td></tr>
</table></p>

<p><big><b>5.2. The first lab program</b></big></p>

#include "mfp_memory_mapped_registers.h"

int main ()
{
    long long int n = 0;

    for (;;)
    {
        /*
        MFP_RED_LEDS      = n;
        MFP_GREEN_LEDS    = n;
        MFP_7_SEGMENT_HEX = n;
        */

        MFP_RED_LEDS   = n >> 16;
        MFP_GREEN_LEDS = n >> 16;
        MFP_7_SEGMENT_HEX = ((n >> 8) & 0xffffff00) | (n & 0xff);

        n ++;

        // asm ("mfc0 $8, $15, 0");
        // MFP_7_SEGMENT_HEX = 1;
    }

    return 0;
}


<p><big><b>5.3. First step: cleaning all</b></big></p>

<p>This step is optional. It removes all files generated by other steps.</p>

<blockquote><p>File <i>00_clean_all.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>                                  
rd /s /q sim

del *.o
del main.s
del program.elf
del program.map
del program.dis
del program*.hex
del program.rec
del FPGA_Ram.elf

</pre></font></blockquote>

<p><big><b>5.4. Compiling the software</b></big></p>

<p><big><b>5.4.1. Compiling C program into assembly to examine the generated code</b></big></p>

<p>This step is optional.</p>

<blockquote><p>File <i>01_compile_c_to_assembly.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>                      
rem -EL           - Little-endian
rem -march=m14kc  - MIPSfpga = MIPS microAptiv UP based on MIPS M14Kc
rem -msoft-float  - should not use floating-point processor instructions
rem -O2           - optimization level
rem -S            - compile to assembly

mips-mti-elf-gcc -EL -march=m14kc -msoft-float -O2 -S main.c

</pre></font></blockquote>

<p><big><b>5.4.2. Compiling C and assembly programs and linking them into ELF file</b></big></p>

<p>This step is required.</p>

<blockquote><p>File <i>02_compile_and_link.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>                           
rem -EL             - Little-endian
rem -march=m14kc    - MIPSfpga = MIPS microAptiv UP based on MIPS M14Kc
rem -msoft-float    - should not use floating-point processor instructions
rem -o program.elf  - output file name
rem -O2             - optimization level
rem -T, -Wl         - linked options

mips-mti-elf-gcc -EL -march=m14kc -msoft-float -O2
    -Wl,-Map=program.map -T program.ld
    -Wl,--defsym,__flash_start=0xbfc00000
    -Wl,--defsym,__flash_app_start=0x80000000
    -Wl,--defsym,__app_start=0x80000000
    -Wl,--defsym,__stack=0x80040000
    -Wl,--defsym,__memory_size=0x1f800
    -Wl,-e,0xbfc00000
    boot.S main.c -o program.elf

</pre></font></blockquote>

<p><big><b>5.4.3. Checking program size</b></big></p>

<p>This step is optional.</p>

<blockquote><p>File <i>03_check_program_size.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>                         
mips-mti-elf-size program.elf

</pre></font></blockquote>

<p><big><b>5.4.4. Using disassembly program</b></big></p>

<p>This step is optional.</p>

<blockquote><p>File <i>04_disassemble.bat</i></p><font size=3 face="Lucida Console,Monaco,monospace"><pre>                                
mips-mti-elf-objdump -D program.elf &gt; program.dis

</pre></font></blockquote>
